// SPDX-FileCopyrightText: Â© 2026 PrivKey LLC
// SPDX-License-Identifier: AGPL-3.0-or-later

namespace keep_mobile {
    [Throws=KeepMobileError]
    ParsedBunkerUrl parse_bunker_url(string url);

    string format_timestamp(i64 ts);
    string format_timestamp_detailed(i64 ts);
    string truncate_str(string s, u32 prefix_len, u32 suffix_len);
};

[Error]
interface KeepMobileError {
    NotInitialized();
    RequestNotFound();
    InvalidSession();
    BiometricRequired();
    BiometricFailed();
    StorageError(string msg);
    StorageNotFound();
    NetworkError(string msg);
    FrostError(string msg);
    InvalidShare(string msg);
    TooManyPendingRequests();
    Timeout();
    InvalidRelayUrl(string msg);
    InitializationFailed(string msg);
    NotSupported(string msg);
    Serialization(string msg);
    PubkeyMismatch();
    RateLimited();
    InvalidTimestamp();
    PsbtError(string msg);
    PolicyViolation(string reason);
    InvalidPolicy(string msg);
    PolicySignatureInvalid();
    CertificatePinMismatch(string hostname, string expected, string actual);
};

dictionary ShareMetadataInfo {
    string name;
    u16 identifier;
    u16 threshold;
    u16 total_shares;
    sequence<u8> group_pubkey;
};

dictionary ShareInfo {
    string name;
    u16 share_index;
    u16 threshold;
    u16 total_shares;
    string group_pubkey;
};

dictionary StoredShareInfo {
    string group_pubkey;
    string name;
    u16 share_index;
    u16 threshold;
    u16 total_shares;
    i64 created_at;
    i64? last_used;
    u64 sign_count;
};

dictionary SignRequest {
    string id;
    sequence<u8> session_id;
    string message_type;
    string message_preview;
    u16 from_peer;
    u64 timestamp;
    SignRequestMetadata? metadata;
};

dictionary SignRequestMetadata {
    u32? event_kind;
    string? content_preview;
    u64? amount_sats;
    string? destination;
};

dictionary PsbtInfo {
    u32 num_inputs;
    u32 num_outputs;
    u64 total_input_sats;
    u64 total_output_sats;
    u64 fee_sats;
    sequence<PsbtOutputInfo> outputs;
};

dictionary PsbtOutputInfo {
    u32 index;
    string? address;
    u64 amount_sats;
    boolean is_change;
};

dictionary PsbtInputSighash {
    u32 input_index;
    sequence<u8> sighash;
};

interface PsbtParser {
    [Throws=KeepMobileError, Name=from_base64]
    constructor(string base64_psbt);

    [Throws=KeepMobileError, Name=from_bytes]
    constructor(sequence<u8> data);

    [Throws=KeepMobileError]
    PsbtParser set_network(string network);

    [Throws=KeepMobileError]
    PsbtInfo analyze();

    [Throws=KeepMobileError]
    sequence<PsbtInputSighash> get_taproot_sighashes();

    [Throws=KeepMobileError]
    sequence<u8> get_sighash_for_input(u32 input_index);

    string to_base64();

    sequence<u8> to_bytes();

    u32 get_input_count();

    u32 get_output_count();
};

dictionary PeerInfo {
    u16 share_index;
    string? name;
    PeerStatus status;
};

dictionary CertificatePin {
    string hostname;
    string spki_hash;
};

enum PeerStatus {
    "Online",
    "Offline",
    "Unknown",
};

dictionary WalletDescriptorInfo {
    string group_pubkey;
    string external_descriptor;
    string internal_descriptor;
    string network;
    u64 created_at;
};

dictionary RecoveryTierConfig {
    u32 threshold;
    u32 timelock_months;
};

dictionary DescriptorProposal {
    string session_id;
    string network;
    sequence<RecoveryTierConfig> tiers;
};

dictionary AnnouncedXpubInfo {
    string xpub;
    string fingerprint;
    string? label;
};

dictionary RelayConfigInfo {
    sequence<string> frost_relays;
    sequence<string> profile_relays;
    sequence<string> bunker_relays;
};

dictionary ProxyConfigInfo {
    boolean enabled;
    u16 port;
};

[Trait, WithForeign]
interface DescriptorCallbacks {
    [Throws=KeepMobileError]
    void on_proposed(string session_id);
    [Throws=KeepMobileError]
    void on_contribution_needed(DescriptorProposal proposal);
    [Throws=KeepMobileError]
    void on_contributed(string session_id, u16 share_index);
    [Throws=KeepMobileError]
    void on_complete(string session_id, string external_descriptor, string internal_descriptor);
    [Throws=KeepMobileError]
    void on_failed(string session_id, string error);
    [Throws=KeepMobileError]
    void on_xpub_announced(u16 share_index, sequence<AnnouncedXpubInfo> xpubs);
};

[Trait, WithForeign]
interface SecureStorage {
    [Throws=KeepMobileError]
    void store_share(sequence<u8> data, ShareMetadataInfo metadata);

    [Throws=KeepMobileError]
    sequence<u8> load_share();

    boolean has_share();

    ShareMetadataInfo? get_share_metadata();

    [Throws=KeepMobileError]
    void delete_share();

    [Throws=KeepMobileError]
    void store_share_by_key(string key, sequence<u8> data, ShareMetadataInfo metadata);

    [Throws=KeepMobileError]
    sequence<u8> load_share_by_key(string key);

    sequence<ShareMetadataInfo> list_all_shares();

    [Throws=KeepMobileError]
    void delete_share_by_key(string key);

    string? get_active_share_key();

    [Throws=KeepMobileError]
    void set_active_share_key(string? key);
};

interface KeepMobile {
    [Throws=KeepMobileError]
    constructor(SecureStorage storage);

    [Throws=KeepMobileError]
    void initialize(sequence<string> relays);

    [Throws=KeepMobileError]
    ShareInfo import_share(string data, string passphrase, string name);

    sequence<SignRequest> get_pending_requests();

    [Throws=KeepMobileError]
    void approve_request(string request_id);

    void reject_request(string request_id);

    sequence<PeerInfo> get_peers();

    boolean has_share();

    ShareInfo? get_share_info();

    [Throws=KeepMobileError]
    void delete_share();

    [Throws=KeepMobileError]
    string export_share(string passphrase);

    sequence<StoredShareInfo> list_shares();

    StoredShareInfo? get_active_share();

    [Throws=KeepMobileError]
    void set_active_share(string group_pubkey);

    [Throws=KeepMobileError]
    void delete_share_by_key(string group_pubkey);

    [Throws=KeepMobileError]
    sequence<CertificatePin> get_certificate_pins();

    [Throws=KeepMobileError]
    void clear_certificate_pins();

    [Throws=KeepMobileError]
    void clear_certificate_pin(string hostname);

    sequence<WalletDescriptorInfo> wallet_descriptor_list();

    [Throws=KeepMobileError]
    string wallet_descriptor_export(string group_pubkey, string format);

    [Throws=KeepMobileError]
    void wallet_descriptor_delete(string group_pubkey);

    void wallet_descriptor_set_callbacks(DescriptorCallbacks callbacks);

    [Throws=KeepMobileError]
    string wallet_descriptor_propose(string network, sequence<RecoveryTierConfig> tiers);

    [Throws=KeepMobileError]
    void wallet_descriptor_cancel(string session_id);

    [Throws=KeepMobileError]
    void wallet_descriptor_approve_contribution(string session_id);

    [Throws=KeepMobileError]
    void wallet_announce_xpubs(sequence<AnnouncedXpubInfo> xpubs);

    [Throws=KeepMobileError]
    RelayConfigInfo get_relay_config(string? group_pubkey);

    [Throws=KeepMobileError]
    void save_relay_config(string? group_pubkey, RelayConfigInfo config);

    [Throws=KeepMobileError]
    void delete_relay_config(string? group_pubkey);

    [Throws=KeepMobileError]
    ProxyConfigInfo get_proxy_config();

    [Throws=KeepMobileError]
    void save_proxy_config(ProxyConfigInfo config);
};

dictionary ParsedBunkerUrl {
    string pubkey;
    sequence<string> relays;
    string? secret;
};

enum BunkerStatus {
    "Stopped",
    "Starting",
    "Running",
    "Error",
};

dictionary BunkerLogEvent {
    string app;
    string action;
    boolean success;
    string? detail;
};

dictionary BunkerApprovalRequest {
    string app_pubkey;
    string app_name;
    string method;
    u32? event_kind;
    string? event_content;
    string? requested_permissions;
};

[Trait, WithForeign]
interface BunkerCallbacks {
    void on_log(BunkerLogEvent event);
    boolean request_approval(BunkerApprovalRequest request);
};

interface BunkerHandler {
    constructor(KeepMobile mobile);

    [Throws=KeepMobileError]
    void start_bunker(sequence<string> relays, BunkerCallbacks callbacks);

    void stop_bunker();

    string? get_bunker_url();

    BunkerStatus get_bunker_status();
};

enum Nip55RequestType {
    "GetPublicKey",
    "SignEvent",
    "Nip04Encrypt",
    "Nip04Decrypt",
    "Nip44Encrypt",
    "Nip44Decrypt",
    "DecryptZapEvent",
};

dictionary Nip55Request {
    Nip55RequestType request_type;
    string content;
    string? pubkey;
    string return_type;
    string compression_type;
    string? callback_url;
    string? id;
    string? current_user;
    string? permissions;
};

dictionary Nip55Response {
    string result;
    string? event;
    string? error;
    string? id;
};

interface Nip55Handler {
    constructor(KeepMobile mobile);

    [Throws=KeepMobileError]
    Nip55Response handle_request(Nip55Request request, string caller_id);

    sequence<Nip55Response> handle_batch_request(sequence<Nip55Request> requests, string caller_id);

    [Throws=KeepMobileError]
    Nip55Request parse_intent_uri(string uri);

    [Throws=KeepMobileError]
    string build_result_intent(Nip55Response response, string package);

    string serialize_batch_results(sequence<Nip55Response> responses);
};
