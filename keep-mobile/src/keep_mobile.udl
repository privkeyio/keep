// SPDX-FileCopyrightText: Â© 2026 PrivKey LLC
// SPDX-License-Identifier: AGPL-3.0-or-later

namespace keep_mobile {};

[Error]
enum KeepMobileError {
    "NotInitialized",
    "RequestNotFound",
    "InvalidSession",
    "BiometricRequired",
    "BiometricFailed",
    "StorageError",
    "NetworkError",
    "FrostError",
    "InvalidShare",
    "TooManyPendingRequests",
    "Timeout",
    "InvalidRelayUrl",
    "InitializationFailed",
    "NotSupported",
    "Serialization",
    "PubkeyMismatch",
    "RateLimited",
    "InvalidTimestamp",
};

dictionary ShareMetadataInfo {
    string name;
    u16 identifier;
    u16 threshold;
    u16 total_shares;
    sequence<u8> group_pubkey;
};

dictionary ShareInfo {
    string name;
    u16 share_index;
    u16 threshold;
    u16 total_shares;
    string group_pubkey;
};

dictionary StoredShareInfo {
    string group_pubkey;
    string name;
    u16 share_index;
    u16 threshold;
    u16 total_shares;
    i64 created_at;
    i64? last_used;
    u64 sign_count;
};

dictionary SignRequest {
    string id;
    sequence<u8> session_id;
    string message_type;
    string message_preview;
    u16 from_peer;
    u64 timestamp;
    SignRequestMetadata? metadata;
};

dictionary SignRequestMetadata {
    u32? event_kind;
    string? content_preview;
    u64? amount_sats;
    string? destination;
};

dictionary PeerInfo {
    u16 share_index;
    string? name;
    PeerStatus status;
};

enum PeerStatus {
    "Online",
    "Offline",
    "Unknown",
};

[Trait, WithForeign]
interface SecureStorage {
    [Throws=KeepMobileError]
    void store_share(sequence<u8> data, ShareMetadataInfo metadata);

    [Throws=KeepMobileError]
    sequence<u8> load_share();

    boolean has_share();

    ShareMetadataInfo? get_share_metadata();

    [Throws=KeepMobileError]
    void delete_share();

    [Throws=KeepMobileError]
    void store_share_by_key(string key, sequence<u8> data, ShareMetadataInfo metadata);

    [Throws=KeepMobileError]
    sequence<u8> load_share_by_key(string key);

    sequence<ShareMetadataInfo> list_all_shares();

    [Throws=KeepMobileError]
    void delete_share_by_key(string key);

    string? get_active_share_key();

    [Throws=KeepMobileError]
    void set_active_share_key(string? key);
};

interface KeepMobile {
    [Throws=KeepMobileError]
    constructor(SecureStorage storage);

    [Throws=KeepMobileError]
    void initialize(sequence<string> relays);

    [Throws=KeepMobileError]
    ShareInfo import_share(string data, string passphrase, string name);

    sequence<SignRequest> get_pending_requests();

    [Throws=KeepMobileError]
    void approve_request(string request_id);

    void reject_request(string request_id);

    sequence<PeerInfo> get_peers();

    boolean has_share();

    ShareInfo? get_share_info();

    [Throws=KeepMobileError]
    void delete_share();

    [Throws=KeepMobileError]
    string export_share(string passphrase);

    sequence<StoredShareInfo> list_shares();

    StoredShareInfo? get_active_share();

    [Throws=KeepMobileError]
    void set_active_share(string group_pubkey);

    [Throws=KeepMobileError]
    void delete_share_by_key(string group_pubkey);
};

enum BunkerStatus {
    "Stopped",
    "Starting",
    "Running",
    "Error",
};

dictionary BunkerLogEvent {
    string app;
    string action;
    boolean success;
    string? detail;
};

dictionary BunkerApprovalRequest {
    string app_pubkey;
    string app_name;
    string method;
    u32? event_kind;
    string? event_content;
};

[Trait, WithForeign]
interface BunkerCallbacks {
    void on_log(BunkerLogEvent event);
    boolean request_approval(BunkerApprovalRequest request);
};

interface BunkerHandler {
    constructor(KeepMobile mobile);

    [Throws=KeepMobileError]
    void start_bunker(sequence<string> relays, BunkerCallbacks callbacks);

    void stop_bunker();

    string? get_bunker_url();

    BunkerStatus get_bunker_status();
};

enum Nip55RequestType {
    "GetPublicKey",
    "SignEvent",
    "Nip04Encrypt",
    "Nip04Decrypt",
    "Nip44Encrypt",
    "Nip44Decrypt",
    "DecryptZapEvent",
};

dictionary Nip55Request {
    Nip55RequestType request_type;
    string content;
    string? pubkey;
    string return_type;
    string compression_type;
    string? callback_url;
    string? id;
    string? current_user;
    string? permissions;
};

dictionary Nip55Response {
    string result;
    string? event;
    string? error;
    string? id;
};

interface Nip55Handler {
    constructor(KeepMobile mobile);

    [Throws=KeepMobileError]
    Nip55Response handle_request(Nip55Request request, string caller_id);

    sequence<Nip55Response> handle_batch_request(sequence<Nip55Request> requests, string caller_id);

    [Throws=KeepMobileError]
    Nip55Request parse_intent_uri(string uri);

    [Throws=KeepMobileError]
    string build_result_intent(Nip55Response response, string package);

    string serialize_batch_results(sequence<Nip55Response> responses);
};
